package rgo

import (
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"os"
	"os/exec"
	"runtime"
	"strconv"
	"strings"

	"github.com/uluyol/rgo/dataframe"
)

// Conn is used to start and communicate with an R process. Conn
// is NOT thread-safe. However, you may run multiple Conn's in
// the same process safely. It is safe to run successive
// operations on Conn successively and retrieve any errors
// using Error(). Do not that although R warnings will be
// returned in method calls, they will not be captured in Error().
//
// Objects in R will not be freed until the Conn is closed.
type Conn struct {
	cmd     *exec.Cmd
	inPipe  io.WriteCloser
	counter uint64
	server  *server

	err     error
	strict  bool
	closed  <-chan struct{}
	waitErr error
}

func (c *Conn) isClosed() bool {
	select {
	case <-c.closed:
		return true
	default:
		return false
	}
}

func (c *Conn) start() error {
	err := c.cmd.Start()
	if err != nil {
		return err
	}
	ch := make(chan struct{})
	c.closed = ch
	go func() {
		state, err := c.cmd.Process.Wait()
		if err != nil {
			c.waitErr = err
		} else if !state.Success() {
			c.waitErr = rError("an execution error occured")
		}
		close(ch)
		c.inPipe.Close()
		c.cmd.Wait() // clean up resources
	}()
	return err
}

type connConfig struct {
	debug bool
}

type ConnOption func(*connConfig)

func WithDebug() ConnOption {
	return func(c *connConfig) {
		c.debug = true
	}
}

const checkDepsCmd = "cat(is.element(\"jsonlite\", installed.packages()[,1]) & is.element(\"RCurl\", installed.packages()[,1]))\n"

func Connection(opts ...ConnOption) (*Conn, error) {
	var cfg connConfig
	for _, opt := range opts {
		opt(&cfg)
	}
	var c Conn
	out, err := exec.Command("R", "--no-save", "-s", "-e", checkDepsCmd).CombinedOutput()
	if err != nil {
		return nil, fmt.Errorf("failed to check dependencies: %v", err)
	}
	if string(out) != "TRUE" {
		if cfg.debug {
			fmt.Printf("got: %s", out)
		}
		return nil, errors.New("need to install 'jsonlite' and 'RCurl'")
	}
	c.cmd = exec.Command("R", "--no-save")
	pr, pw := io.Pipe()
	c.cmd.Stdin = pr
	c.inPipe = pw
	if cfg.debug {
		c.cmd.Stdout = os.Stdout
		c.cmd.Stderr = os.Stderr
	}
	if err != nil {
		return nil, err
	}
	err = c.start()
	if err != nil {
		return nil, err
	}
	if err != nil {
		c.Close()
		return nil, err
	}
	c.server, err = newServer()
	if err != nil {
		goto ErrCleanup
	}
	err = c.directR("library(jsonlite)\n")
	if err != nil {
		goto ErrCleanup
	}
	err = c.directR("library(RCurl)\n")
	if err != nil {
		goto ErrCleanup
	}
	runtime.SetFinalizer(&c, func(c *Conn) { c.Close() })
	return &c, nil

ErrCleanup:
	c.Close()
	return nil, err
}

func (c *Conn) Close() error {
	if c.isClosed() {
		return c.waitErr
	}
	c.directR("q()")
	c.inPipe.Close()
	<-c.closed
	err1 := c.waitErr
	err2 := c.server.s.Stop()
	if err1 != nil {
		return err1
	}
	return err2
}

// directR sends the command to R without trapping errors.
// directR should only be used for registring some internal functions.
func (c *Conn) directR(cmd string) error {
	_, err := io.WriteString(c.inPipe, cmd)
	return err
}

const cmdStr = `..rgo.ret = c("", "")
tryCatch({
	%s
}, warning = function(w) {
	..rgo.ret[1] <<- conditionMessage(w)
}, error = function(e) {
	..rgo.ret[2] <<- conditionMessage(e)
})
print(..rgo.ret)
httpPUT("http://localhost:%d/%s", toJSON(..rgo.ret))
`

type res struct {
	Error   string
	Warning string
	strict  bool
}

type rError string

func (e rError) Error() string { return string(e) }
func (e rError) IsError()      {}

type rWarning string

func (w rWarning) Error() string { return string(w) }
func (w rWarning) IsWarning()    {}

func (r res) toError() error {
	if r.Error != "" {
		return rError(r.Error)
	} else if r.Warning != "" {
		if r.strict {
			return rError(r.Warning)
		}
		return rWarning(r.Warning)
	}
	return nil
}

// Strict sets all warnings to become errors. Setting this is
// recommended as R is generous as to what constitutes an error.
func (c *Conn) Strict() error {
	c.strict = true
	return c.R("options(warn=2)")
}

// R sends a command to R. An Error or Warning generated by the
// command will be returned as an RError or RWarning.
func (c *Conn) R(cmd string) error {
	if c.err != nil {
		return c.err
	}
	key := "r.result"
	rch := make(chan readerDone)
	c.server.putFwd(key, rch)
	defer c.server.rmFwd(key)
	fmt.Fprintf(c.inPipe, cmdStr, cmd, c.server.port, key)
	var rd readerDone
	select {
	case <-c.closed:
		c.err = c.waitErr
		return c.err
	case thisRD := <-rch:
		rd = thisRD
	}
	defer close(rd.done)
	dec := json.NewDecoder(rd.r)
	var resultPair []string
	if err := dec.Decode(&resultPair); err != nil {
		c.err = fmt.Errorf("error while decoding result: %v", err)
		return c.err
	}
	if len(resultPair) != 2 {
		c.err = fmt.Errorf("invalid result pair: %v has length %d", resultPair, len(resultPair))
		return c.err
	}
	result := res{resultPair[0], resultPair[1], c.strict}
	c.err = result.toError()
	if IsWarning(c.err) {
		err := c.err
		c.err = nil
		return err
	}
	return c.err
}

// Rf is like R but takes a format string and arguments.
func (c *Conn) Rf(format string, args ...interface{}) error {
	return c.R(fmt.Sprintf(format, args...))
}

func (c *Conn) getuid() uint64 {
	x := c.counter
	c.counter++
	return x
}

func (c *Conn) write(data interface{}) (string, error) {
	b, err := json.Marshal(data)
	if err != nil {
		return "", err
	}
	key := fmt.Sprintf("go.data.%d", c.getuid())
	c.server.putData(key, b)
	return key, nil
}

// Send sends data into R. data must be json-serializable.
func (c *Conn) Send(data interface{}, name string) error {
	if c.err != nil {
		return c.err
	}
	key, err := c.write(data)
	if key != "" {
		defer c.server.rmData(key)
	}
	if err != nil {
		c.err = err
		return err
	}
	return c.Rf("%s = fromJSON(getURL(\"http://localhost:%d/%s\"))", name, c.server.port, key)
}

// SendDF sends a DataFrame and properly unpacks it as an
// R data frame.
func (c *Conn) SendDF(df dataframe.DataFrame, name string) error {
	colNames := df.ColNames()
	colVars := make([]string, len(colNames))
	for i := range colNames {
		col := df.ColIndex(i)
		colVars[i] = "..rgo.df.cols." + strconv.Itoa(i)
		if err := c.Send(col, colVars[i]); err != nil {
			return err
		}
		// jsonlite may interpret integers as integers. This is not
		// desirable because R often treats integers more like enums
		// than integers. Force all numeric types to become doubles.
		if col.Len() > 0 && dataframe.IsNumeric(col.GetIndexSD(0)) {
			err := c.Rf("%s <- as.double(%s)", colVars[i], colVars[i])
			if err != nil {
				return err
			}
		}
	}
	allColVars := strings.Join(colVars, ", ")
	if err := c.Send(colNames, "..rgo.df.colNames"); err != nil {
		return err
	}
	var err error
	if rowNames, ok := df.RowNames(); ok {
		if err := c.Send(rowNames, "..rgo.df.rowNames"); err != nil {
			return err
		}
		err = c.Rf("..rgo.df.result <- data.frame(%s, row.names=..rgo.df.rowNames)", allColVars)
	} else {
		err = c.Rf("..rgo.df.result <- data.frame(%s)", allColVars)
	}
	if err != nil {
		return err
	}
	if err := c.R("colnames(..rgo.df.result) <- ..rgo.df.colNames"); err != nil {
		return err
	}
	return c.Rf("%s <- ..rgo.df.result", name)
}

// Get gets data from R. data will be deserialized from json.
func (c *Conn) Get(data interface{}, name string) error {
	if c.err != nil {
		return c.err
	}
	key := fmt.Sprintf("r.data.%d", c.getuid())
	rch := make(chan readerDone)
	c.server.putFwd(key, rch)
	defer c.server.rmFwd(key)

	errCh := make(chan error)
	go func() {
		errCh <- c.Rf("httpPUT(\"http://localhost:%d/%s\", toJSON(%s))", c.server.port, key, name)
	}()

	rd := <-rch
	dec := json.NewDecoder(rd.r)
	err := dec.Decode(data)
	close(rd.done)
	c.err = <-errCh
	if c.err != nil {
		return c.err
	}
	c.err = err
	return err
}

// Error returns the first error that occured in the sequence of
// operations. R warnings are ignored.
func (c *Conn) Error() error {
	return c.err
}

type RError interface {
	error
	IsError()
}

type RWarning interface {
	error
	IsWarning()
}

func IsError(e error) bool {
	_, ok := e.(RError)
	return ok
}

func IsWarning(e error) bool {
	_, ok := e.(RWarning)
	return ok
}
